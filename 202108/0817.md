# 오늘 배운 것

* 자바스크립트 this 키워드
* 자바스크립트 ES6, ES11 문법

# 회고

오늘은 자바스크립트 개념 중에서 `this`와 `ES6, ES11` 문법을 공부했다. 특히, `this`는 면접에서도 자주 나왔던 키워드이기 때문에 다시 한번 복습해서 완벽하게(?) 이해하려고 노력했다. this는 함수마다 정의되는 의미가 달라진다. 일반 함수는 `호출 위치`에 따라 this 키워드가 정의되고, 화살표 함수는 자신이 선언된 `함수 범위`에서 this 키워드가 정의된다. 

```
const whoAmI = {
  name: 'bxxmi',
  normal: function () {
    console.log(this.name);
  },
  arrow: () => {
    console.log(this.name);
  }
}

whoAmI.normal(); // 결과: bxxmi
whoAmI.arrow(); // 결과: undefined
```

위 결과가 나오는 이유는 간단하다. whoAmI 객체 데이터에서 일반 함수로 정의된 normal은 `whoAmI.normal()`을 통해 호출됐고, 자신을 호출하고 있는 whoAmI 객체 데이터가 this에 담기게 되어 bxxmi 값이 나온 것이다. 그러나, 화살표 함수로 선언된 arrow는 주변에 자신을 선언한 함수가 보이질 않는다. 따라서 this(=자신을 선언한/감싸고 있는 함수)를 찾을 수 없으니 undefined가 출력된다. 

그다음 자바스크립트에서 객체 데이터를 생성할 때 key와 value 값이 같다면 다음과 같이 하나로 축약해서 사용할 수 있다.

```
const student1 = {
  name,
  age
} 
```

또, `구조 분해 할당(=비구조화 할당)`을 배웠다. 처음 공부했을 때는 'key를 사용해서 원하는 데이터만 추출한다'처럼 얕게 배웠는데 key 이름을 변경해서 새로운 변수로 사용할 수 있다는 점과 배열에서도 사용할 수 있음을 알게 되었다. 특히, 배열에서는 순서대로 값이 저장되기 때문에 이 속성을 통해서 중간에 값을 바로 추가할 수 있다는 장점도 알게 되었다. 더 나아가 ES11에서 추가된 `Optional Chaining`은 어마 무시한 퍼포먼스를 나타내는 것을 알게 되었다. '?' 키워드를 사용해서 체이닝 되어있는 객체들의 속성 값의 false 유무를 확인하고 true 일 때 값을 출력하게 된다. 또, `Nullish Coalescing`도 처음 알게 되었는데 이걸 왜 몰랐을까 싶었다. 내가 알고 있는 자바스크립트 지식은 var 변수 사용에 멈춰있었으니 당연한 건가..😢 '??' 키워드를 사용해서 원래는 false로 인식할 값들을 입력한 그대로 인식해서 출력되도록 한다. 즉, 사용자가 0을 입력하거나, 공백을 입력했을 때 그것을 false로 처리하지 않고 입력한 그대로의 값을 보여준다. 해당 연산자는 금액을 입력받을 때의 오류 처리 시 응용해서 사용할 수 있을 것 같다는 생각이 들었다.

