# 01. 데이터 타입

📚 코어 자바스크립트 책을 읽고 요약 정리한 문서입니다.

* [사전 지식](#사전-지식)
* [데이터 타입 종류](#데이터-타입-종류)
* [변수 선언과 데이터 할당 원리](#변수-선언과-데이터-할당-원리)
* [불변 객체](#불변-객체)
* [얕은 복사와 깊은 복사](#얕은-복사와-깊은-복사)
* [undefined와 null](#undefined와-null)

## 사전 지식

자바스크립트의 데이터 타입을 알아보기 전에 자바스크립트가 **타입 유연성**을 가지게 된 배경지식을 갖고 있는 것이 좋다. C/C++, java 등 정적 언어 타입은 메모리 낭비를 최소화하기 위해서 데이터 타입별로 
할당할 메모리 영역을 나눠서 지정했다. 때문에 사용자가 지정된 메모리 이상의 수를 입력하면 오류가 발생하게 되고, 이를 대처하기 위해서는 사용자가 직접 형변환을 해야하는 불편함이 있었다. 

그러나, 메모리 용량이 과거보다 커진 상황에서 등장한 자바스크립트는 상대적으로 메모리 관리에 대한 압박에 자유로웠다. 때문에 변수의 타입을 구분하지 않고 넉넉한 용량을 확보하게 되어 개발자가 형변환을 걱정해야 하는 
상황이 덜 발생하게 됐다. 

여기서 말하는 메모리가 데이터 타입과 관련해서 가장 중요한 개념이 된다. 메모리는 고유한 식별자를 가지고 0과 1로 데이터를 표현할 수 있는 비트 묶음(바이트)의 집합이며 모든 데이터는 바이트 단위의 식별자,
더 정확하게는 **메모리 주소값**을 통해 서로 구분하고 연결할 수 있다.

> 💡**정적 언어 VS 동적 언어**
>
> 정적 언어와 동적 언어의 차이는 **타입이 결정되는 시간**에 있다. 정적 언어는 `컴파일 시 타입이 결정`되기 때문에 C/C++, java 등의 언어에서는 변수 선언 시 항상 타입을 지정해야하는 반면에 javascript와 같은 동적 언어는
> `런타임 시 타입이 결정`되기 때문에 변수에 타입을 지정할 필요가 없이 개발자가 코드를 빠르게 작성할 수 있다. 

## 데이터 타입 종류

자바스크립트의 데이터 타입에는 기본형, 참조형 두 가지가 존재한다.

* `기본형` : number, string, boolean, undefined, null

* `참조형` : array, object, function, date, map, weakmap, set, weakset

위와 같이 두 가지로 나뉜 기준은 변수에 값을 할당하는 방법에 있다. 기본형 데이터 타입은 값이 담긴 주소값을 바로 복제해서 값을 할당하는 반면, 참조형은 값이 담긴 주소값들의 묶음을 가리키는 주소값을 복제한다.
여기서 눈치를 챘을 수도 있지만 **사실, 어떤 데이터 타입이든 변수에 값을 할당하기 위해서는 주소값을 복제한다는 점에서 자바스크립트의 모든 데이터 타입은 참조형 데이터일 수 밖에 없다.**
다만, 기본형은 주소값을 복사하는 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거친다는 차이가 있다.

## 변수 선언과 데이터 할당 원리

* 기본형 데이터 타입

```javascript
var a = 10;
```

a라는 식별자를 가진 변수가 있다. 변수란 **결국 변경 가능한 데이터가 담길 수 있는 공간**을 말하며 이 공간에는 숫자를 담거나 문자를 담거나 등 다양한 명령을 내릴 수 있다.
위 변수 선언 명령을 받은 컴퓨터는 메모리에 비어있는 공간 하나를 확보한다. 그 공간의 이름을 a라고 지정하며 a에 10이라는 데이터 값을 할당할 때 a라는 이름을 가진 
주소를 검색해 그 공간에 데이터를 할당한다. 이후 사용자가 a에 접근할 때 컴퓨터는 메모리에서 a라는 이름을 가진 주소를 검색하고 해당 공간에 담긴 데이터를 반환한다.

그러나, 이때 할당한 값을 a 위치에 직접 저장하지 않는다. **데이터를 저장하기 위한 별도의 메모리 공간을 다시 확보한 후 그 공간에 값을 할당하고, 해당 공간의 메모리 주소를 변수 영역에 대입하는 것이다.**

이렇게 `변수 영역`과 `데이터 영역`을 분리해서 데이터를 관리하는 이유는 **데이터 변환을 자유롭게 할 수 있음과 동시에 메모리를 더 효율적으로 관리하기 위함이다.**
만약, 이미 확보한 공간 내에서만 데이터 변환이 가능하다면 변환된 데이터를 다시 저장하기 위해서는 해당 공간의 크기를 변환된 데이터 크기에 맞게 컴퓨터가 또 연산을 처리해야한다는 불편함이 있다.
때문에, 변환된 데이터가 담길 공간을 따로 만들고 그 공간의 주소값을 변수 공간에 연결하면 데이터 처리 효율이 높아지게 된다.

**이러한 점에서 기본형 데이터는 값의 변경 시 변경된 값이 담기는 데이터 공간이 따로 생기기 때문에 불변값이라고 하는 것이다.**

>💡**불변값**
>
> 변수와 상수를 구분하는 기준은 변경 가능성이다. 바꿀 수 있으면 변수, 바꿀 수 없으면 상수인데 상수를 불변값이라고 생각하기 쉽다. 변수와 상수를 구분짓는 변경 가능성의 대상은 `변수 영역 메모리`이고,
> 불변성 여부를 구분할 때 변경 가능성의 대상은 `데이터 영역 메모리`이다. 위에서도 말했듯이 데이터를 변경하게 되면 새로운 데이터 공간이 생기게 되는데 이게 바로 불변값의 성질이다.

* 참조형 데이터 타입

참조형 데이터는 기본적으로 가변값이지만 경우에 따라 불변값으로 활용하기도 한다. 우선, 참조형 데이터 타입의 할당 원리를 살펴보자.

```javascript
var obj = {
  a: 1,
  b: 'b'
}
```

참조형 데이터는 총 3가지의 영역이 생긴다. obj가 담기는 **변수 영역**과 a, b 프로퍼티 주소가 담기는 **데이터 영역(불변값)**, 해당 프로퍼티 값이 담기는 **프로퍼티 영역이다.**
기본형 데이터와의 차이점은 프로퍼티 영역이 별도로 존재한다는 점이다. 참조형 데이터가 별도로 할애한 영역은 프로퍼티 영역뿐이기 때문에 데이터 영역은 기존의 메모리 공간을 그대로 활용하고 있다.
이때, 데이터 영역에 저장된 값은 모두 불변성이지만 프로퍼티 변수 영역에는 다른 값을 얼마든지 대입할 수 있기 때문에 참조형 데이터는 가변값이라고 하는 것이다.

## 불변 객체

참조형 데이터 활용 시 객체를 변경하더라도 원본 객체는 변하지 않아야 하는 경우가 있다. 예를 들면, 같은 형태의 객체를 활용하는 과정에서 일부 프로퍼티의 값을 변경할 경우이다.

```javascript
var user = {
  name: 'Bomi',
  gender: 'female'
};

var changeName = function (user, newName) {
  var newUser = user;
  newUser.name = newName;
  return newUser;
};

var user2 = changeName(user, 'Kim Bo mi');

console.log(user.name, user2.name); // Kim Bo mi, Kim Bo mi
console.log(user === user2) // true
```

위 코드는 우리가 의도한 바와 다른 값이 출력된다. user 객체를 복사해서 이름을 변경했을 뿐인데 name 프로퍼티의 값이 변경된 값으로 모두 변경되었으며, user객체와 user2 객체의 주소값이 같다고 나오는 것이다.
만약, 바뀌기 전의 정보와 바뀐 후 정보의 차이를 가시적으로 나타내야하는 기능을 구현하려면 서로 다른 객체를 바라보게 만들어야 한다. 즉, 서로 다른 메모리 주소를 가진 프로퍼티 영역을 새로 만들어야 한다는 것이다.

```javascript
var user = {
  name: 'Bomi',
  gender: 'female'
};

var changeName = function (user, newName) {
  return {
    name: newName,
    gender: user.gender
  }
};

var user2 = changeName(user, 'Kim Bo mi');

console.log(user.name, user2.name); // Bomi, Kim Bo mi
console.log(user === user2) // false
```

위 코드로 changeName 함수가 새로운 객체를 리턴하도록 수정했다. 한 가지 아쉬운 점은 변경할 필요가 없는 기존 객체의 gender 프로퍼티를 하드코딩으로 입력한 것이다. 이런 방식은 효율적이지 않고,
복사하려는 대상 객체의 프로퍼티 개수에 상관없이 모든 프로퍼티를 복수하는 함수를 만드는 편이 좋다.

## 얕은 복사와 깊은 복사

불변 객체를 만들 때 아쉬운 복사를 했었다. 자바스크립트의 복사 개념에 얕은 복사와 깊은 복사가 존재하는데 위에 예시로 든 복사는 얕은 복사에 속한다. 

* 얕은 복사

얕은 복사란 바로 아래 단계의 값만 복사하는 방법이며, 중첩된 객체가 있는 경우 해당 프로퍼티의 주소값을 복사해서 그대로 사용하기 때문에 원본과 사본이 모두 동일한 참조형 데이터 주소를 
가리키게 되어 원본 값은 그대로 사라진다는 단점이 있다.

다음은 중첩된 객체에 대한 얕은 복사 예시이다.

```javascript
var user = {
  name: 'Bomi',
  urls: {
    portfolio: '',
    blog: '',
    facebook: ''
  }
}

var user2 = copyObject(user);

user2.name = 'Kim';
console.log(user.name === user2.name); // false

user.urls.portfolio = 'a';
console.log(user.urls.portfolio === user2.urls.portfolio); // true
```

* 깊은 복사

깊은 복사는 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법이다. 

다음은 중첩된 객체에 대한 얕은 복사 예시이다.

```javascript
var user = {
  name: 'Bomi',
  urls: {
    portfolio: '',
    blog: '',
    facebook: ''
  }
}

var user2 = copyObject(user); // 최상단 객체 복사
var user2.urls = copyObject(user.urls); // 최상단 객체의 하위 객체(=중첩된 객체) 복사

user.urls.portfolio = 'a';
console.log(user.urls.portfolio === user2.urls.portfolio); // false
```

## undefined와 null

자바스크립트에서 없음을 나타내는 값이 두 가지가 있다. 바로, undefined와 null이다. 두 값의 의미는 같지만 또 다르고 사용하는 목적도 다르다.

우선, undefined는 사용자가 명시적으로 지정할 수도 있지만 값이 존재하지 않을 때 자바스크립트 엔진이 자동으로 부여하기도 한다. 즉, 자바스크립트 엔진은 사용자가 어떤 값을 지정할 것이라고 
예상되는 상황임에도 실제로는 값을 지정하지 않았다면 undefined를 반환한다. 

배열의 경우 조금 특이한 동작을 확인할 수 있다. 만약, `var arr = [];` 와 같이 빈 배열을 만들고 `console.log`로 확인을 하면 문자 그대로 어떤 값도 즉, undefined이라는 값도 확인할 수 없다.
즉, 비어있는 요소와 undefined가 직접 값으로 할당된 요소는 출력 결과부터 다르며 **비어있는 배열은 순회 대상에서 제외가 된다.**

undefined가 비록 비어있음을 의미하지만 하나의 값으로 동작하기 때문에 이때의 프로퍼티나 배열의 요소는 고유의 키 값이 존재하게 되고 순회의 대상이 될 수 있다. 때문에, 
사용자는 비어있음을 명시적으로 나타내고 싶을 때 null을 쓰고, 그 외의 모든 경우는 자바스크립트 엔진이 자동적으로 undefined를 반환하도록 하는 것이 좋다.
